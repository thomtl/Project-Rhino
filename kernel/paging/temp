void page_fault(registers_t *regs);

void page_fault(registers_t *regs){
  uint32_t faulting_address;
  __asm__ ("mov %%cr2, %0" : "=r" (faulting_address));

  int present   = !(regs->err_code & 0x1); // Page not present
  int rw = regs->err_code & 0x2;           // Write operation?
  int us = regs->err_code & 0x4;           // Processor was in user-mode?
  int reserved = regs->err_code & 0x8;     // Overwritten CPU-reserved bits of page entry?

  // Output an error message.
  kprint("Page fault! ( ");
  if (present) {kprint("present ");}
  if (rw) {kprint("read-only ");}
  if (us) {kprint("user-mode ");}
  if (reserved) {kprint("reserved ");}
  kprint(") at ");
  char address[35] = "";
  hex_to_ascii(faulting_address, address);
  kprint(address);
  kprint("\n");
  panic_m("Page Fault");
}

  register_interrupt_handler(14, page_fault);

  void initialise_paging(uint32_t memSize){
    uint32_t mem_end_page = memSize;//0x1000000;

    nframes = mem_end_page / 0x1000;
    frames = (uint32_t*)kmalloc(INDEX_FROM_BIT(nframes));
    memset(frames, 0, INDEX_FROM_BIT(nframes));

    kernel_directory = (page_directory_t*)kmalloc_a(sizeof(page_directory_t));
    memset(kernel_directory, 0, sizeof(page_directory_t));
    current_directory = kernel_directory;

    uint32_t i = 0;

    for(i = KHEAP_START; i < KHEAP_START+KHEAP_INITIAL_SIZE; i += 0x1000){
      get_page(i, 1, kernel_directory);
    }

    i = 0;
    while(i < placement_address+0x1000){
      page_t* usepage = get_page(i, 1, kernel_directory);
      alloc_frame(usepage, 0, 0);
      i += 0x1000;
    }
    for(i = KHEAP_START; i < KHEAP_START+KHEAP_INITIAL_SIZE; i += 0x1000){
      page_t* usepage = get_page(i, 1, kernel_directory);
      alloc_frame(usepage, 0, 0);
    }
    switch_page_directory(kernel_directory);
    kheap = create_heap(KHEAP_START, KHEAP_START+KHEAP_INITIAL_SIZE, 0xCFFFF000, 0, 0);
  }
